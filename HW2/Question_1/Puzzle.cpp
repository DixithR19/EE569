// This sample code reads in image data from a RAW image file and // writes it into another file// NOTE:	The code assumes that the image is of size 256 x 256 and is in the//			RAW format. You will need to make corresponding changes to//			accommodate images of different sizes and/or types#include <stdio.h>#include <iostream>#include <stdlib.h>#include <math.h>#define PI 3.14159265using namespace std;unsigned char ImagePiece[500][500][3];unsigned char ImagePiece2[500][500][3];unsigned char HPiece[150][150][3];unsigned char Hillary[512][512][3];unsigned char Trump[512][512][3];unsigned char ImagePiece1[500][500][3];int main(int argc, char *argv[]){	// Define file pointer and variables	FILE *file;	int BytesPerPixel;	int Size1,Size2,Size3,Size4;	// Check for proper syntax	if (argc < 3) {		cout << "Syntax Error - Incorrect Parameter Usage:" << endl;		cout << "program_name pieces.raw hillary.raw trump.raw output_image1.raw output_image2.raw [BytesPerPixel] [Size1] [Size2] [Size3] [Size4]" << endl;		return 0;	}	// Check if image is grayscale or color	if (argc < 4) {		BytesPerPixel = 1; // default is grey image	}	else {		BytesPerPixel = atoi(argv[6]);		// Check if size is specified		if (argc >= 5) {			Size1 = atoi(argv[7]);			Size2 = atoi(argv[8]);			Size3 = atoi(argv[9]);			Size4 = atoi(argv[10]);		}	}	// Allocate image data array			for (int i = 0; i < Size1; i++) {		for (int j = 0; j < Size2; j++) {			for (int k = 0; k < 3; k++) {				ImagePiece1[i][j][k] = 255;			}		}	}	// Read image (filename specified by first argument) into image data matrix	if (!(file = fopen(argv[1], "rb"))) {		cout << "Cannot open file: " << argv[1] << endl;		exit(1);	}	fread(ImagePiece, sizeof(unsigned char), Size1*Size2*BytesPerPixel, file);	fclose(file);	if (!(file = fopen(argv[2], "rb"))) {		cout << "Cannot open file: " << argv[2] << endl;		exit(1);	}	fread(Hillary, sizeof(unsigned char), Size3*Size4*BytesPerPixel, file);	fclose(file);	if (!(file = fopen(argv[3], "rb"))) {		cout << "Cannot open file: " << argv[3] << endl;		exit(1);	}	fread(Trump, sizeof(unsigned char), Size3*Size4*BytesPerPixel, file);	fclose(file);	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////		//Seperating Puzzle Piece 1	for (int i = 0; i < (Size1 / 2); i++) {		for (int j = 0; j < (Size2 / 2); j++) {			if (ImagePiece[i][j][0] != 255 && ImagePiece[i][j][1] != 255 && ImagePiece[i][j][2] != 255) {				for (int k = 0; k < 3; k++) {					ImagePiece1[i][j][k] = ImagePiece[i][j][k];				}			}		}	}	//Finding four coordinates of Piece 1	int x1, y1, x2, y2, x3, y3, x4, y4;	for (int i = 0; i < Size1 ; i++) {		for (int j = Size2-1; j > 0 ; j--) {			if (ImagePiece1[i][j][0] != 255 || ImagePiece1[i][j][1] != 255 || ImagePiece1[i][j][2] != 255) {				x4 = i;				y4 = j;				break;			}		}	}			for (int j = 0; j < Size2; j++) {		for (int i = Size1-1; i > 0; i--) {			if (ImagePiece1[i][j][0] != 255 || ImagePiece1[i][j][1] != 255 || ImagePiece1[i][j][2] != 255) {				x2 = i;				y2 = j;				break;			}		}	}		for (int j = Size2-1 ; j > 0; j--) {		for (int i = Size1-1; i > 0; i--) {			if (ImagePiece1[i][j][0] != 255 || ImagePiece1[i][j][1] != 255 || ImagePiece1[i][j][2] != 255) {				x3 = i;				y3 = j;				break;			}		}	}		for (int i = Size1-1; i > 0; i--) {		for (int j = 0; j < Size2; j++) {			if (ImagePiece1[i][j][0] != 255 || ImagePiece1[i][j][1] != 255 || ImagePiece1[i][j][2] != 255) {				x1 = i;				y1 = j;				break;			}		}	}		double theta;	theta = atan((double)(x2 - x1) / (double)(y2 - y1)) ;		// Finding coordinates of Hillary Missing part	int x11, y11, x22, y22, x33, y33, x44, y44;	for (int i = 0; i < Size3; i++) {		for (int j = 0; j < Size4; j++) {			if (Hillary[i][j][0] == 255 && Hillary[i][j][1] == 255 && Hillary[i][j][2] == 255) {				x33 = i;				y33 = j;				break;			}		}			}		for (int i = Size1; i >0; i--) {		for (int j = 0; j < Size4; j++) {			if (Hillary[i][j][0] == 255 && Hillary[i][j][1] == 255 && Hillary[i][j][2] == 255) {				x11 = i;				y11 = j;				break;			}		}	}	for (int i = Size1; i >0; i--) {		for (int j = Size2; j >0; j--) {			if (Hillary[i][j][0] == 255 && Hillary[i][j][1] == 255 && Hillary[i][j][2] == 255) {				x22 = i;				y22 = j;				break;			}		}	}		for (int i = 0; i < Size1; i++) {		for (int j = Size2; j > 0; j--) {			if (Hillary[i][j][0] == 255 && Hillary[i][j][1] == 255 && Hillary[i][j][2] == 255) {				x44 = i;				y44 = j;				break;			}		}	}		//Rotation of Piece1	double u, v;		for (int i = 0; i <Size1; i++) {		for (int j = 0; j <Size2; j++) {			for (int k = 0; k < 3; k++) {								ImagePiece1[i][j][k] = ImagePiece1[(int)(((double)i*cos(theta))+((double)j*sin(theta)))][(int)(((double)j*cos(theta)) - ((double)i*sin(theta)))][k];			}		}	}	cout << "dixith" << endl;	// Removing garbage	for (int i = Size1 / 2; i < Size1; i++) {		for (int j = 0; j < Size2; j++) {			for (int k = 0; k < 3; k++) {				ImagePiece1[i][j][k] = 255;			}		}	}	//Translation	for (int i = Size1 - 1; i > 0; i--) {		for (int j = 0; j < Size2; j++) {			if (ImagePiece1[i][j][0] != 255 || ImagePiece1[i][j][1] != 255 || ImagePiece1[i][j][2] != 255) {				x1 = i;				y1 = j;				break;			}		}	}		for (int i = 0; i < Size1; i++) {		for (int j = 0; j < Size2; j++) {			for (int k = 0; k < 3; k++) {				ImagePiece1[i][j][k]=ImagePiece1[i+x1][j+y1][k];			}		}	}	// Removing garbage	for (int i = Size1 / 2; i < Size1; i++) {		for (int j = 0; j < Size2; j++) {			for (int k = 0; k < 3; k++) {				ImagePiece1[i][j][k] = 255;			}		}	}		// Scaling	for (int i = 0; i < Size1; i++) {		for (int j = 0; j < Size2; j++) {						for (int k = 0; k < 3; k++) {								ImagePiece1[(int)((double)i*(0.666667))][(int)((double)j*(0.666667))][k] =ImagePiece1[i][j][k];			}		}	}		// Putting the Piece back into the face	for (int i = 0; i < 100; i++) {		for (int j = 0; j < 100; j++) {			for (int k = 0; k < 3; k++) {				Hillary[i + x11][j + y11][k] = ImagePiece1[i][j][k];			}		}	}	// Write image data (filename specified by second argument) from image data matrix	if (!(file = fopen(argv[4], "wb"))) {		cout << "Cannot open file: " << argv[4] << endl;		exit(1);	}	fwrite(Hillary, sizeof(unsigned char), Size3*Size4*BytesPerPixel, file);	fclose(file);		////////////////////////////// For Trump ////////////////////////////////////	for (int i = 0; i < Size1; i++) {		for (int j = 0; j < Size2; j++) {			for (int k = 0; k < 3; k++) {				ImagePiece1[i][j][k] = 255;			}		}	}	//Seperating Puzzle Piece 2	for (int i = Size1/2; i < Size1; i++) {		for (int j = Size2/2; j < Size2; j++) {			if (ImagePiece[i][j][0] != 255 && ImagePiece[i][j][1] != 255 && ImagePiece[i][j][2] != 255) {				for (int k = 0; k < 3; k++) {					ImagePiece1[i][j][k] = ImagePiece[i][j][k];				}			}		}	}	//Rotation of Piece 2	for (int j = 0; j < Size2; j++) {		for (int i = Size1 - 1; i > 0; i--) {			if (ImagePiece1[i][j][0] != 255 || ImagePiece1[i][j][1] != 255 || ImagePiece1[i][j][2] != 255) {				x3 = i;				y3 = j;				break;			}		}	}		for (int i = Size1 - 1; i >= 0; i--) {		for (int j = Size2-1; j >= 0; j--) {			if (ImagePiece1[i][j][0] != 255 || ImagePiece1[i][j][1] != 255 || ImagePiece1[i][j][2] != 255) {				x4 = i;				y4 = j;				break;			}		}	}	theta = -1.5708;		//Rotation		for (int c = 0; c < 3; c++) {		for (int i = 0; i < Size1; i++) {			for (int j = 0; j < Size2; j++) {				for (int k = 0; k < 3; k++) {					ImagePiece1[(int)(((double)i*cos(theta)) + ((double)j*sin(theta)))][(int)(((double)j*cos(theta)) - ((double)i*sin(theta)))][k] = ImagePiece1[i][j][k];									}			}		}		for (int i = 0; i < Size1; i++) {			for (int j = 0; j < Size2; j++) {				for (int k = 0; k < 3; k++) {					ImagePiece1[i][j][k] = ImagePiece1[i - 499][j][k];				}			}		}	}	for (int i = 0; i < Size1; i++) {		for (int j = 0; j < Size2; j++) {			for (int k = 0; k < 3; k++) {				ImagePiece2[i][j][k] = ImagePiece1[i][Size2 - 1 - j][k];			}		}	}	theta = atan((double)(y4 - y3) / (double)(x4 - x3));	for (int i = 0; i < Size1; i++) {			for (int j = 0; j < Size2; j++) {								for (int k = 0; k < 3; k++) {										ImagePiece2[i][j][k]=ImagePiece2[(int)(((double)i*cos(theta)) + ((double)j*sin(theta)))][(int)(((double)j*cos(theta)) - ((double)i*sin(theta)))][k] ;				}			}		}	for (int i = 0; i < Size1; i++) {		for (int j = 0; j < Size2; j++) {			for (int k = 0; k < 3; k++) {				ImagePiece1[i][j][k] = ImagePiece2[i][Size2 - 1 - j][k];			}		}	}	// Removing Garbage	for (int i = 400; i < Size1; i++) {		for (int j = 0; j < Size2; j++) {			for (int k = 0; k < 3; k++) {				ImagePiece1[i][j][k] = 255;			}		}	 }	for (int i = 0; i < Size1; i++) {		for (int j = Size2/2; j < Size2; j++) {			for (int k = 0; k < 3; k++) {				ImagePiece1[i][j][k] = 255;			}		}	}	// Translation	for (int i = Size1 - 1; i > 0; i--) {		for (int j = 0; j < Size2; j++) {			if (ImagePiece1[i][j][0] != 255 || ImagePiece1[i][j][1] != 255 || ImagePiece1[i][j][2] != 255) {				x1 = i;				y1 = j;				break;			}		}	}		for (int i = Size1 - 1; i > 0; i--) {		for (int j = Size2-1; j > 0; j--) {			if (ImagePiece1[i][j][0] != 255 || ImagePiece1[i][j][1] != 255 || ImagePiece1[i][j][2] != 255) {				x2 = i;				y2 = j;				break;			}		}	}		for (int i = 0; i < Size1; i++) {		for (int j = Size2 - 1; j > 0; j--) {			if (ImagePiece1[i][j][0] != 255 || ImagePiece1[i][j][1] != 255 || ImagePiece1[i][j][2] != 255) {				x4 = i;				y4 = j;				break;			}		}	}		int sx = y2 - y1;	int sy = x4 - x2;		for (int i = 0; i < Size1; i++) {		for (int j = 0; j < Size2; j++) {			for (int k = 0; k < 3; k++) {				ImagePiece1[i][j][k] = ImagePiece1[i + x1][j + y1][k];			}		}	}	// Removing Garbage	for (int i = 150; i < Size1; i++) {		for (int j = 0; j < Size2; j++) {			for (int k = 0; k < 3; k++) {				ImagePiece1[i][j][k] = 255;			}		}	}	// Scaling	unsigned char TPiece1[sx][sy][BytesPerPixel];	unsigned char TPiece2[100][100][BytesPerPixel];	for (int i = 0; i <= sx; i++) {		for (int j = 0; j <= sy; j++) {			for (int k = 0; k < 3; k++) {				TPiece1[i][j][k] = ImagePiece1[i][j][k];			}		}	}	for (int i = 0; i < 100; i++) {		for (int j = 0; j < 100; j++) {			for (int k = 0; k < 3; k++) {				double p = ((double)sx / 100)*(double)i;				double q = ((double)sy / 100)*(double)j;				double x = p - floor(p);				double y = q - floor(q);				int p1 = p;				int q1 = q;				TPiece2[i][j][k] = (1 - x)*(1 - y)*TPiece1[p1][q1][k] + (x)*(1 - y)*TPiece1[p1][q1 + 1][k] +					(1 - x)*(y)*TPiece1[p1 + 1][q1][k] + (x)*(y)*TPiece1[p1 + 1][q1 + 1][k];			}		}	}		// Putting the Piece 2 back	for (int i = Size1; i >0; i--) {		for (int j = 0; j < Size4; j++) {			if (Trump[i][j][0] == 255 && Trump[i][j][1] == 255 && Trump[i][j][2] == 255) {				x11 = i;				y11 = j;				break;			}		}	}		for (int i = Size1; i >0; i--) {		for (int j = Size2; j >0; j--) {			if (Trump[i][j][0] == 255 && Trump[i][j][1] == 255 && Trump[i][j][2] == 255) {				x22 = i;				y22 = j;				break;			}		}	}		for (int i = 0; i < 100; i++) {		for (int j = 0; j < 100; j++) {			for (int k = 0; k < 3; k++) {				Trump[i + x11][j + y11][k] = TPiece2[i][j][k];			}		}	}			for (int j = y11; j < y11 + 100; j++) {			for (int k = 0; k < 3; k++) {				Trump[x11][j][k] = Trump[x11 - 1][j][k];				Trump[x11 + 2][j][k] = Trump[x11 + 3][j][k];				Trump[x11+1][j][k] = (Trump[x11][j][k]+ Trump[x11+2][j][k])/2;			}		}			for (int i = x11; i < x11 + 100; i++) {			for (int k = 0; k < 3; k++) {				Trump[i][y11][k] = Trump[i][y11 - 1][k];				Trump[i][y11 + 1][k] = Trump[i][y11 + 2][k];				Trump[i][y22][k] = Trump[i][y22 + 1][k];				Trump[i][y22 - 1][k] = Trump[i][y22 - 2][k];			}		}			if (!(file = fopen(argv[5], "wb"))) {		cout << "Cannot open file: " << argv[5] << endl;		exit(1);	}	fwrite(Trump, sizeof(unsigned char), Size3*Size4*BytesPerPixel, file);	fclose(file);	return 0;}